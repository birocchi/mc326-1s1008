\documentclass{article}
\usepackage[brazil]{babel}
\usepackage[utf8]{inputenc}

\title{\textbf{Relatório TP3}}
\author{\textbf{Grupo 1} \\
  Anderson Phillip Birocchi (072787) \\
  Miguel Francisco Alves de Mattos Gaiowski (076116) \\
  Raphael Kubo da Costa (072201)}
\date{\today}
\begin{document}

\maketitle

\section{Objetivo}\

Este trabalho prático tem como objetivo a implementação de consulta por índices secundários e a remoção de entradas numa base de dados como requisitos adicionais aos já implementados durante o trabalho prático anterior.\\

Este relatório detalha algumas decisões de design e arquitetura feitas durante o desenvolvimento, além de uma descrição do código fonte e um guia de uso do programa.

\section{Alterações}\

Dentre as principais alterações no código e nas funcionalidades do programa em relação ao trabalho prático anterior, podemos destacar:\\

\textbf{Funcionalidades}:
\begin{itemize}
 \item Adicionada a remoção de entradas por índice primário e índices secundários;
\item Adicionada consulta por índices secundários;
\item As informações em HTML são listadas em tabela, com o NRR de cada entrada;
\item Não há mais diferença entre maiúsculas e minúsculas nas buscas.
\end{itemize}

\textbf{Código}:
\begin{itemize}
 \item Criada uma estrutura \texttt{MemoryIndex} para representar os índices em memória;
\item Criada uma estrutura \texttt{Adapter}, correspondente ao \textit{design pattern} de mesmo nome, para gerenciar e fazer a interface entre a base de dados, o índice primário e os índices secundários;
\item Criada a estrutura \texttt{SecondaryIndex} para representar os índices secundários;
\item Criada a estrutura \texttt{AvailList} para representar a \textit{avail list} utilizada nas remoções e inserções;
\item A maior parte do código de \textit{main} foi movida para \textit{adapter.c};
\item Agora é feito um uso massivo da função \texttt{assert} para checagem de dados e para facilitar o debugging do programa.
\item pk.c e pk.h foram removidos;
\end{itemize}

\section{Uso da interface}\

O programa gerado pelo \textit{Makefile} chama-se \textbf{tp3} e deve ser rodado a partir de um terminal. Seu menu inicial apresenta as seguintes opções: \textbf{inserir} uma nova entrada na base de dados, \textbf{consultar} uma obra existente no banco de dados, \textbf{gerar} uma lista com informações sobre todas as obras da base de dados, \textbf{remover} uma obra e \textbf{sair}.

A opção é selecionada digitando-se \textbf{i} para inserir, \textbf{c} para consultar, \textbf{g} para gerar a lista de obras, \textbf{r} para remover e \textbf{s} para sair.\\

\subsection{Inserção}\

No modo de \textbf{inserção}, o usuário deve digitar as informações para \textit{nome da obra}, \textit{tipo de obra}, \textit{autor da obra}, \textit{ano em que a obra foi feita}, \textit{valor da obra} e um \textit{identificador da obra}. Determinados campos possuem restrições: ano e valor devem conter apenas dígitos, e o identificador precisa terminar nas extensões \textit{png, jpg} ou \textit{gif} e ser precedido por até quatro dígitos. Caso já exista uma obra com mesmo nome na base de dados, o usuário deve entrar com outros dados de obra. Feita a inserção, o usuário pode escolher inserir uma nova obra ou voltar para o menu principal.\\

\subsection{Consulta}\

No modo de \textbf{consulta}, o usuário deve primeiro escolher se deseja uma busca \textit{parcial} ou \textit{exata}. Em ambos os casos, não há diferença entre maiúsculas e minúsculas nos itens pesquisados.\\

Uma busca \textit{parcial} é feita somente nos índices secundários do banco de dados. É possível buscar por \textbf{ano}, \textbf{tipo}, \textbf{título} ou \textbf{autor} da obra. Neste modo de pesquisa, é possível buscar por apenas \textbf{uma} palavra, que retornará as entradas que contiverem a palavra buscada.\\

Uma busca \textit{exata} é feita somente no índice primário (título da obra), e busca o título exato entrado pelo usuário.\\

Os resultados encontrados são escritos com os campos NRR, título, tipo, autor, ano de criação, valor e identificador no arquivo \textbf{lista.html}. Caso não haja nenhum resultado, exibe-se uma mensagem de erro.

\subsection{Geração de lista}

No modo de \textbf{geração de lista}, escreve-se no arquivo \textbf{lista.html} uma lista com as informações (NRR, título, tipo, autor, ano de criação, valor e identificador) de todas as obras cadastradas na base de dados. Caso não haja nenhuma obra na base de dados, exibe-se uma mensagem de erro.

\subsection{Remoção}

No modo de \textbf{remoção}, o usuário deve entrar com o NRR (número relativo de registro) da obra que deseja excluir do banco de dados. O NRR é obtido através de uma \textbf{consulta} ou \textbf{geração} de lista de obras. Enquanto o NRR entrado não for válido, o usuário é perguntado por um novo NRR válido para exclusão.

\section{Descrição do Trabalho}\

Desde a versão anterior foi definida uma divisão dos códigos fonte para melhor manutenção e escalabilidade. Com o crescimento das funcionalidades e necessidade de melhor base para algumas destas, acabou-se modificando a estrutura dos arquivos para melhor adequação. Atualmente, os seguintes arquivos compõem o programa:

\begin{itemize}
\item \textbf{adapter.c, adapter.h}\\
	\textit{Design pattern} utilizada como uma espécie de ``cola'' entre as diversas partes do sistema: coordena índices e base para buscas, remoções e inserções.

\item \textbf{avail.c, avail.h}\\
	Contêm as funções referentes à manipulação das avail lists usadas pelos índices e pela base de dados.

\item \textbf{base.c, base.h}\\
	Contêm as funções referentes à manipulação da base de dados e definições relacionadas, como o tamanho dos campos da base de dados e a estrutura que representa uma entrada na base de dados. Há funções para adição e remoção na base de dados, além de funções auxiliaries que validam o identificador e lêem entradas na base de dados.

 \item \textbf{file.c, file.h}\\
	Contêm funções relacionadas à manipulação de arquivos quaisquer: atualmente, checa se determinado arquivo existe, retorna o tamanho de determinado arquivo e checa se o arquivo é válido para o trabalho (possui tamanho maior que 0).

\item \textbf{filelist.h}\\
	Contêm os nomes dos arquivos utilizados pelo banco de dados (base, chaves primárias, secundárias e avail lists), de modo a evitar nomes \textit{hardcoded} no código.

 \item \textbf{html.c, html.h}\\
	Contêm as funções relacionadas à manipulação e geração de arquivos HTML para consultas e listas usadas pelo programa, para automatizar o processo de escrita de dados. Atualmente, cria o começo e o fim de um arquivo HTML e escreve as informações de uma entrada no banco de dados em formato HTML.

 \item \textbf{io.c, io.h}\\
	Controlam a leitura e escrita de dados entrados pelo usuário. Já no Trabalho Prático 2 foi implementada uma função para limpar caracteres em branco em excesso nas strings. Neste trabalho, foram implementadas uma função para ler somente a primeira palavra de uma string e um \textit{foreach} para que uma string tenha uma função chamada para cada palavra.

 \item \textbf{main.c}\\
	Contém a lógica de execução do programa. Inicia a base de dados e a lista de chaves primárias e depois recebe as opções de operações desejadas pelo usuário, tratando-as e chamando as funções necesśarias em outros arquivos.

 \item \textbf{mem.c, mem.h}\\
	Contêm macros e funções para facilitar a alocação de memória para o programa: basicamente, as macros alocam o número desejado de bytes na memória e já abortam o programa em caso de erro.
	
 \item \textbf{menu.c, menu.h}\\
	Contêm as funções de exibição dos menus usados pelo programa, além de funções para análise das opções de menu entradas pelo usuário.

 \item \textbf{secindex.c, secindex.h}\\
	Responsáveis pela manipulação dos índices secundários do banco de dados: adicionam, buscam e removem índices secundários.
\end{itemize}

\section{Arquivos gerados e existentes}\

\begin{itemize}
 \item \textbf{author, type, title, year.av}: Avail list dos índices secundários de autores, títulos, tipos e anos.
 \item \textbf{author, type, title, year.sk}: Índices de memória escritos em disco para os índices de autores, títulos, tipos e anos.
 \item \textbf{author, type, title, year.sl}: Listas \textit{entry-based} de referências à chave primária para os índices de autores, títulos, tipos e anos.
 \item \textbf{base01.dat}: Base de dados utilizada pelo programa.
 \item \textbf{entrada.in}: Entradas usadas para popular a base dados.
 \item \textbf{lista.html}: Resultado das consultas à base de dados.
 \item \textbf{pkfile.pk}: Arquivo de ``cache'' das chaves primárias (título das obras).
\end{itemize}

\section{Decisões de design}\

Durante a escrita do código deste trabalho prático, percebeu-se que os indices secundários e primários compartilhavam algumas características em comum. Em tempo de execução, os índices primários ficam armazenados em memória e são compostos por um \textit{nome} (uma string) e um \textit{identificador} (também chamado de \textit{valor}, \textit{id} ou \textit{NRR}). Os índices secundários, por sua vez, são compostos por duas camadas: uma lista em memória em ordem alfabética composta também por \textit{nome} e \textit{identificador} e uma lista em disco com chave primária e seu respectivo NRR. A lista em memória é idêntica à utilizada pelas chaves primárias, contendo apenas valores de nomes e identificadores diferentes. Assim, para reusar código, removeram-se \textit{pk.c} e \textit{pk.h}, que foram substituídos por \textit{memindex.c} e \textit{memindex.h}, que contêm as estruturas \texttt{MemoryIndex} e \texttt{MemoryIndexRecord}.

\section{Chaves primárias}\

Decidiu-se utilizar uma estrutura \textit{PrimaryKeyList} para armazenar as chaves primárias composta pelo número atual de registros armazenados (\textit{regnum}), o número máximo de registros que podem ser armazenados (\textit{maxregs}) e uma estrutura interna (\textit{PrimaryKeyRecord}) para armazenamento do número relativo de registro (\textit{rrn}) e o nome da entrada (\textit{name}).

Optou-se por essa estrutura devido à sua facilidade de manutenção e expansão para os futuros trabalhos, caso sejam adicionados novos campos. Inicialmente, utilizou-se apenas um ponteiro para ponteiro que separava número relativo de registro e nome em suas estruturas. Entretanto, a dificuldade de manutenção e utilização dessa estrutura e sua falta de escalabilidade também nos motivaram a buscar algo mais robusto.

A estrutura \textit{PrimaryKeyRecord} é de uso interno das bibliotecas do programa, e o usuário tem contato somente com os campos que ela contém (\textit{rrn} e \textit{name}) quando executa operações em \textit{PrimaryKeyList}.

Para se iniciar uma instância de \textit{PrimaryKeyList} utiliza-se um equivalente a um ``construtor'', \textit{pkListInit}, responsável por alocar memória para a lista interna e iniciar os valores de número de registros e máximo de registros permitidos. Ao fim do uso, deve-se chamar \textit{pkListFree} no objeto criado, de modo a desalocar a memória utilizada.

Em certa medida, o uso de estruturas internas e funções para criação e destruição de objetos baseia-se no código de softwares livres como a biblioteca GTK+, disponível em \textit{www.gtk.org}. Como foi dito, isso facilita a manutenção e a escalabilidade das estruturas utilizadas e implementa um certo nível de abstração e orientação a objetos ao utilizar uma forma rudimentar de encapsulamento.

Como documentado em \textbf{pk.h}, há diversas funções para manipulação da lista de chaves primárias para inserção e busca dos dados. Para este trabalho prático, não foram implementadas operações de remoção.

Sempre que a lista de chaves primárias é carregada a partir da base de dados ou quando insere-se uma nova entrada, a lista, presente na memória, é organizada utilizando-se a função \textit{qsort} em ordem alfabética, para possibilitar uma posterior busca binária por nome das entradas.

Ainda em relação à inserção de entradas, sempre é realizada uma checagem de número de entradas disponíveis na lista antes da inserção. Desse modo, quando a lista já está cheia com entradas e uma nova entrada deve ser inserida, chama-se a função estática \textit{pkListInflateSize}, que duplica o número de ``slots'' de memória alocados para entradas na lista. Foi decidido por começar a lista com 20 ``slots'' alocados, pois é o número mínimo de registros exigidos para a base de dados.

\section{Resultado final e comentários}\

Conseguimos fazer um programa sem bugs conhecidos e sem vazamentos de memória encontrados. As consultas e listagem de obras funcionam perfeitamente.

As maiores dificuldades foram encontradas durante a implementaçãodas funções de manipulação de chaves primárias. Desde a escolha da melhor estrutura de dados até a perfeição do sistema de controle de alocação de memória encontramos várias possibilidades diferentes de implementação, e isso caracterizou boa parte do desafio desse Trabalho Prático.

Além disso, persistiu a dificuldade do Trabalho Prático 1 de \textit{fgets} e \textit{strncpy}. Devido à maneira como a linguagem C trata strings, deve-se sempre tomar cuidado com o parâmetro de tamanho passado para as funções.

A parte de geração de um arquivo HTML foi de extrema facilidade, sendo que ainda assim causa uma melhoria muito grande na forma como o programa trabalha. O fato de poder ver as imagens num browser ao invés de só ver as informações num terminal deixou o resultado final muito mais interessante.

Deve-se notar também a implementação das funções \textit{stripNewLine} e \textit{stripWhiteSpace}. Atualmente, são duas funções separadas devido à necessidade de se substituir apenas o caractere de ``newline'', $\backslash$n, por um ``null character'', $\backslash$0 nas strings lidas por \textit{fgets} e, se nenhum ``newline'' for encontrado, chamar a função \textit{flushBuffer}, já que isso indica que há caracteres não lidos por \textit{fgets}. A implementação de \textit{stripNewLine} tem uma performance de O(n) no pior caso, pois chama a função \textit{strchr} que percorre a string toda buscando a primeira ocorrência do caractere desejado. Em seguida, a função \textit{stripWhiteSpace} percorre novamente a string toda para eliminar espaços em excesso. No fim, tem-se O(2n) para cada entrada lida por \textit{readValue}. Por enquanto, isso não representa um problema devido ao pequeno número de entradas, mas, caso a base de dados cresça muito, essa complexidade pode representar um \textit{bottleneck} difícil de detectar.

Ainda em relação a \textit{stripWhiteSpace}, não era necessária sua implementação neste Trabalho Prático. Deve-se atentar para o fato de que, caso o usuário entre com uma string com espaços que ultrapassem o limite de caracteres pedido e houverem caracteres válidos depois desses espaços, eles não serão lidos por \textit{fgets} e não constarão nem mesmo na string com os espaços removidos. Para evitar que isso acontecesse, a forma de recepção das entradas do usuário deveria mudar radicalmente, uma vez que seriam permitidas entradas quase infinitas devido ao número de espaços que seriam depois removidos. Acredita-se que isso esteja fora do escopo deste Trabalho Prático.

Finalmente, é preciso tomar cuidado com a consistência entre a base de dados e o ``cache'' de chaves primárias: o programa sempre carrega as chaves primárias do arquivo de chaves caso ele exista, e só recorre à base de dados caso não haja um ``cache''. Isso pode levar a inconsistências nos resultados caso o \textit{cache} esteja desatualizado em relação à base.

\end{document}
