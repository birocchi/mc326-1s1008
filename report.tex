\documentclass[a4paper,10pt]{article}
\usepackage[brazil]{babel}
\usepackage[utf8]{inputenc}

\title{\textbf{Relatório TP4}}
\author{\textbf{Grupo 1} \\
  Anderson Phillip Birocchi (072787) \\
  Miguel Francisco Alves de Mattos Gaiowski (076116) \\
  Raphael Kubo da Costa (072201)}
\date{\today}
\begin{document}

\maketitle

\begin{abstract}
Este trabalho prático possui dois objetivos principais: implementar uma camada de \textit{hashing} para os índices mantidos em memória até o Trabalho Prático anterior, de modo a dividi-los em vários arquivos e carregar somente um deles em memória de cada vez, e implementar uma busca de imagens por similaridade de conteúdo.

Este relatório detalha algumas decisões de design e arquitetura feitas durante o desenvolvimento, além de uma descrição do código fonte e um guia de uso do programa.
\end{abstract}

\section{Alterações}
Dentre as principais alterações no código e nas funcionalidades do programa em relação ao trabalho prático anterior, podemos destacar:\\

\textbf{Funcionalidades}:
\begin{itemize}
\item Adicionada a opção de busca por similaridade de conteúdo entre imagens;
\item O NRR de cada entrada exibida na listagem em HTML não é mais exibido;
\item A opção de listagem de todas as obras foi removida.
\end{itemize}

\textbf{Código}:
\begin{itemize}
\item A estrutura \texttt{MemoryIndex} foi adaptada para ter seu conteúdo em disco dividido em diversos arquivos ao invés de apenas um. Para indicar em qual arquivo determinada entrada está, é utilizada uma função de \textit{hashing} que utiliza o nome da entrada como chave;
\item Criadas uma estrutura \texttt{Descriptor} e as estruturas auxiliares \texttt{SimiliarityList} e \texttt{SimilarityRecord}, para o cadastro das informações do descritor de cada imagem do banco de dados;
\item Boa parte do código da função \texttt{adapter\_find} foi reescrito para suportar de forma limpa e eficiente as três estruturas usadas em busca: \texttt{MemoryIndex}, \texttt{SecondaryIndex} e \texttt{Descriptor}.
\end{itemize}

\section{Uso da interface}
O programa gerado pelo \textit{Makefile} chama-se \textbf{tp4} e deve ser rodado a partir de um terminal. Seu menu inicial apresenta as seguintes opções: \textbf{inserir} uma nova entrada na base de dados, \textbf{consultar} uma obra existente no banco de dados, \textbf{remover} uma obra e \textbf{sair}.

A opção é selecionada digitando-se \textbf{i} para inserir, \textbf{c} para consultar, \textbf{r} para remover e \textbf{s} para sair.

\subsection{Inserção}
No modo de \textbf{inserção}, o usuário deve digitar as informações para \textit{nome da obra}, \textit{tipo de obra}, \textit{autor da obra}, \textit{ano em que a obra foi feita}, \textit{valor da obra} e um \textit{identificador da obra}. Determinados campos possuem restrições: ano e valor devem conter apenas dígitos, e o identificador precisa terminar nas extensões \textit{png, jpg} ou \textit{gif} e ser precedido por até quatro dígitos. Caso já exista uma obra com mesmo nome na base de dados, o usuário deve entrar com outros dados de obra. Feita a inserção, o usuário pode escolher inserir uma nova obra ou voltar para o menu principal.

\subsection{Consulta}
No modo de \textbf{consulta}, o usuário é apresentado às formas de consulta que podem ser realizadas: \textit{parcial}, \textit{exata} ou por \textit{similaridade}.

Uma busca \textit{parcial} é feita somente nos índices secundários do banco de dados. É possível buscar por \textbf{ano}, \textbf{tipo}, \textbf{título} ou \textbf{autor} da obra. Neste modo de pesquisa, é possível buscar por apenas \textbf{uma} palavra, que retornará as entradas que contiverem a palavra buscada. O programa não faz distinção entre maiúsculas e minúsculas.

Uma busca \textit{exata} é feita somente no índice primário (título da obra), e busca o título exato entrado pelo usuário. Neste caso, também não há distinção entre maiúsculas e minúsculas.

A busca por \textit{similaridade} possui outra interface. Inicialmente, o usuário deve entrar com o caminho completo de uma imagem que será usada como base de comparação. Caso a imagem não seja encontrada, ou se não possuir uma das extensões aceitas pelo programa (png, jpg ou gif), uma mensagem de erro é exibida e o usuário é levado novamente ao menu inicial. Se a imagem for um arquivo válido, o programa pergunta ao usuário o número máximo de imagens semelhantes devem ser exibidas em listagem. O programa realiza, então, uma busca em seu banco de dados de imagens por imagens semelhantes à base de comparação e, em seguida, lista as ocorrências juntamente com a imagem base.

Os resultados encontrados são escritos com os campos título, tipo, autor, ano de criação, valor e identificador no arquivo \texttt{lista.html}. Caso não haja nenhum resultado, exibe-se uma mensagem de erro.

\subsection{Remoção}
No modo de \textbf{remoção}, o usuário deve entrar com o título completo da obra que deseja excluir do banco de dados. O programa não realiza distinções entre maísculas e minúculas. O título pode ser obtido através de uma \textbf{consulta} de obras. Quando o título digitado pelo usuário é inválido, é exibida uma mensagem de erro e o programa retorna ao menu inicial.

\section{Descrição do Trabalho}
Em relação à versão anterior do trabalho, não foram feitas grandes alterações na estrutura ou na quantidade de arquivos presentes, ao contrário do que ocorreu na transição entre os trabalhos práticos 2 e 3.

Foram criados apenas os arquivos \texttt{descriptor.c}, \texttt{descriptor.h}, \texttt{hash.c} e \texttt{hash.h}, enquanto os outros arquivos presentes tiveram apenas algumas funcionalidades editadas. Nenhum arquivo de código da versão anterior foi removido. Atualmente, os seguintes arquivos compõem o programa:

\begin{description}
\item[adapter.c, adapter.h:] \textit{Design pattern} utilizada como uma espécie de ``cola'' entre as diversas partes do sistema: coordena índices e base para buscas, remoções e inserções.

\item[avail.c, avail.h:] Contêm as funções referentes à manipulação das avail lists usadas pelos índices e pela base de dados.

\item[base.c, base.h:] Contêm as funções referentes à manipulação da base de dados e definições relacionadas, como o tamanho dos campos da base de dados e a estrutura que representa uma entrada na base de dados. Há funções para adição e remoção na base de dados, além de funções auxiliares que validam o identificador e lêem entradas na base de dados.

\item[descriptor.c, descriptor.h:] Contêm as funções referentes à manipulação do índice de descritores de imagens, incluindo adição, remoção e busca no índice.

 \item[file.c, file.h:] Contêm funções relacionadas à manipulação de arquivos quaisquer: checa se um arquivo existe, se possui uma extensão válida, se não está vazio.

\item[filelist.h:] Contêm os nomes dos arquivos utilizados pelo banco de dados (base, chaves primárias, secundárias e avail lists), de modo a evitar nomes \textit{hardcoded} no código. Possui também a quantidade de índices secundários existentes e o número de arquivos em que o arquivo de índice em memória foi dividido para os índices (com exceção do índice de descritores, que possui contagem própria).

\item[hash.c, hash.h:] Contêm uma função de \textit{hashing} genérica (algoritmo de Fowler/Noll/Vo) e uma função de adição do sufixo correto a um arquivo para a obtenção do arquivo de hashing correto.

\item[html.c, html.h:] Contêm as funções relacionadas à manipulação e geração de arquivos HTML para consultas e listas usadas pelo programa, para automatizar o processo de escrita de dados. Atualmente, cria o começo e o fim de um arquivo HTML e escreve as informações de uma entrada no banco de dados em formato HTML.

 \item[io.c, io.h:] Controlam a leitura e escrita de dados entrados pelo usuário. Já no Trabalho Prático 2 foi implementada uma função para limpar caracteres em branco em excesso nas strings. Neste trabalho, foram implementadas uma função para ler somente a primeira palavra de uma string e um \textit{foreach} para que uma string tenha uma função chamada para cada palavra.

 \item[main.c:] Contém a lógica de execução do programa. Inicia a base de dados e a lista de chaves primárias e depois recebe as opções de operações desejadas pelo usuário, tratando-as e chamando as funções necessárias em outros arquivos.

 \item[mem.c, mem.h:] Contêm macros e funções para facilitar a alocação de memória para o programa: basicamente, as macros alocam o número desejado de bytes na memória e já abortam o programa em caso de erro.
	
 \item[menu.c, menu.h:] Contêm as funções de exibição dos menus usados pelo programa, além de funções para análise das opções de menu entradas pelo usuário.

 \item[secindex.c, secindex.h:] Responsáveis pela manipulação dos índices secundários do banco de dados: adicionam, buscam e removem índices secundários.
\end{description}

\section{Arquivos gerados e existentes}
\begin{description}
\item[doc/api/*:] Documentação da API do sistema em HTML e LaTeX.
\item[author, type, title, year.av:] Avail list dos índices secundários de autores, títulos, tipos e anos.
\item[author, type, title, year.sk.h*:] Índices de memória escritos em disco para os índices de autores, títulos, tipos e anos.
\item[author, type, title, year.sl:] Listas \textit{entry-based} de referências à chave primária para os índices de autores, títulos, tipos e anos.
\item[base01.dat:] Base de dados utilizada pelo programa.
\item[descriptor.desc.h*]: Índice de descritores das imagens da base de dados.
\item[doxygen.conf:] Arquivo de configuração para o Doxygen.
\item[entrada.in:] Entradas usadas para popular a base dados.
\item[lista.html:] Resultado das consultas à base de dados.
\item[pkfile.pk:] Arquivo de ``cache'' das chaves primárias (título das obras).
\end{description}

\section{Decisões de design}
Em face dos novos requisitos apresentados no enunciado deste trabalho prático, à maneira do trabalho prático anterior as primeiras atitudes tomadas foram tentar reutilizar código, encaixar as novas estruturas e os novos requisitos no código atual e, só então, criar novas estruturas.

Inicialmente, foram criados os arquivos \texttt{hash.c} e \texttt{hash.h}. Pensou-se que seriam arquivos grandes, porém devido à implementação da estrutura \texttt{MemoryIndex}, não foram precisas muitas mudanças para atender o requisito de ``quebrar'' o conteúdo da estrutura em vários arquivos ao escrever seu conteúdo em disco. Assim, os arquivos \texttt{hash.c} e \texttt{hash.h} possuem apenas duas funções: uma implementação do algoritmo FNV-1 de \textit{hashing} (ver subseção abaixo) e uma função de manipulação de \textit{strings} responsável por acrescentar o sufixo certo a determinado arquivo (o sufixo ``.hNNNN''). Em \texttt{memindex.c}, foi implementada a função \textit{static} \texttt{change\_hash\_file}, responsável por, dada uma chave, carregar o arquivo onde ela está contida caso ela esteja cadastrada. Foram feitas modificações pontuais nas funções de busca, adição e remoção de entradas para que todas chamassem \texttt{change\_hash\_function} quando precisassem mudar o arquivo carregado.

Percebeu-se que o índice de descritores possuía grande semelhança com a estrutura atual de índices secundários, \texttt{SecondaryIndex}. Assim, a idéia inicial foi tentar criar apenas mais um índice secundário como os já existentes (ano, autor, tipo e título) que conteria o descritor e o nome da obra correspondente (a chave primária).

Entretanto, embora o índice de descritores apresente similaridades com relação aos índices secundários, sua estrutura apresentava diferenças grandes o suficiente para impedir sua implementação como um novo índice secundário sem grandes modificações no código que poderiam causar instabilidades e gerar a necessidade de testes intensivos. Como exemplo de diferença, podemos destacar a composição dupla dos índice secundários. Índices secundários são compostos por uma estrutura em memória que possui um campo único (uma parte do título de obra, ou um ano) e um número relativo de registro que aponta para a parte da estrutura residente no disco, com o nome da obra (chave primária) e um apontador para o elemento anterior da lista, como explicado em aula. Nesta implementação do trabalho prático, essas tarefas são gerenciadas pelas estruturas \texttt{SecondaryIndex} e \texttt{MemoryIndex}. A estrutura de descritores, por sua vez, possui apenas a parte em disco: as entradas no formado \textit{descritor-chave primária} são escritas de maneira não ordenada em disco nos arquivos \texttt{descriptor.desc.hNNNN}, com \texttt{NNNN} variando de \texttt{0000} a \texttt{0008}. Ora, tentar utilizar a estrutura \texttt{SecondaryIndex} para ter acesso a apenas metade de suas funcionalidades seria um erro de design e arquitetura. Por outro lado, separar a parte usada pelas duas estruturas geraria um esforço desnecessário, devido principalmente à falta de recursos de orientação a objetos na linguagem C.

Assim, foram criadas as estruturas \texttt{Descriptor}, \texttt{SimilarityList} e \texttt{SimilarityRecord}, que têm sua estrutura semelhante à de \texttt{MemoryIndex} e \texttt{MemoryRecord}, porém com comportamento diferente principalmente na inserção e busca de dados. As novas estruturas foram implementadas nos arquivos \texttt{descriptor.c} e \texttt{descriptor.h}, que também possuem uma função \textit{static} \texttt{change\_hash\_file} com implementação adaptada às necessidades das novas estruturas.

\subsection{Função de hashing FNV-1}
Para o \textit{hashing} dos índices secundários e do índice primário, foi utilizado o algoritmo FNV-1, de Fowler/Noll/Vo.

\section{Resultado final e comentários}
Conseguimos fazer um programa sem bugs conhecidos e sem vazamentos de memória encontrados. As consultas e remoções funcionam corretamente de acordo com os requisitos mínimos do trabalho prático.

Para controle de versões do código, desde o primeiro trabalho é utilizado o \textbf{Subversion}. O repositório do grupo encontra-se em \textit{http://code.google.com/p/mc326-1s1008}. A partir da versão passada, passou-se a utilizar o \textit{Doxygen} para geração de documentação do código-fonte. Por fim, este relatório e seu fonte em LaTeX encontram-se na pasta dos fontes do programa.

As maiores dificuldades foram encontradas durante o planejamento da implementação das novas funcionalidades do sistema. Foi somente quando parte da estrutura já havia sido implementada que percebeu-se que era possível criar \texttt{MemoryIndex}, e parte do código teve de ser reescrito. Além disso, o código de \textit{adapter.c} ficou maior do que o esperado devido a detalhes do código, como o carregamento correto dos arquivos e a independência das funções. Entretanto, o uso da função \texttt{assert} facilitou a detecção de erros de segmentação e o \textit{gdb} permitiu que o código fosse debugado rapidamente. Pela primeira vez durante os testes foi utilizado o \textit{bug tracker} do projeto no Google Code para o gerenciamento de bugs e correções.

Um detalhe que deve ser notado é o uso das funções \textit{fread} e \textit{fwrite} para leitura e escrita dos NRRs dos índices primários e secundários. Como eles são inteiros, caso fossem escritos com \textit{fprintf} e lidos com \textit{fgets} os 4 bytes seriam ocupados por uma seqüência de bytes em que a conversão de inteiros para strings foi feita de forma literal. Assim, o inteiro -1 seria escrito como ``-001` e não 0xFFFFFFFF. Isso diminui consideravelmente a quantidade possível de inteiros que poderiam ser escritos, além de causar uma corrupção nos arquivos caso o inteiro tivesse mais que 4 dígitos. Para campos string, continuou-se usando \textit{fprintf} e \textit{fgets}.

Finalmente, para os próximos trabalhos pretende-se trabalhar nas idéias presentes no arquivo TODO: renomear algumas funções de \textit{base.c} e mexer na estrutura de \textit{ArtworkInfo} se necessário, além de criar um ''wrapper`` para a função \texttt{fopen} para diminuir algumas linhas de código fazendo-se a checagem da abertura dos arquivos automaticamente e uma automatização da leitura da estrutura nome e NRR.

\end{document}
